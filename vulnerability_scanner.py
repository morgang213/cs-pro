import requests
import socket
import ssl
import urllib3
from urllib.parse import urlparse
import json
import re

# Disable SSL warnings for testing purposes
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'CyberSec-Scanner/1.0'
        })
    
    def assess_target(self, target, assessment_type="web_application"):
        """
        Perform vulnerability assessment on target
        """
        try:
            if assessment_type == "web_application":
                return self._assess_web_application(target)
            elif assessment_type == "network_service":
                return self._assess_network_service(target)
            elif assessment_type == "ssl_tls":
                return self._assess_ssl_tls(target)
            else:
                return self._assess_web_application(target)
                
        except Exception as e:
            print(f"Error assessing target {target}: {str(e)}")
            return None
    
    def _assess_web_application(self, url):
        """
        Assess web application vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Ensure URL has protocol
            if not url.startswith(('http://', 'https://')):
                url = 'http://' + url
            
            parsed_url = urlparse(url)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
            
            # Check for common web vulnerabilities
            vulnerabilities.extend(self._check_http_headers(base_url))
            vulnerabilities.extend(self._check_directory_traversal(base_url))
            vulnerabilities.extend(self._check_xss_reflection(base_url))
            vulnerabilities.extend(self._check_sql_injection(base_url))
            vulnerabilities.extend(self._check_information_disclosure(base_url))
            
            return {
                'target': url,
                'assessment_type': 'web_application',
                'vulnerabilities': vulnerabilities,
                'total_vulnerabilities': len(vulnerabilities),
                'risk_level': self._calculate_risk_level(vulnerabilities)
            }
            
        except Exception as e:
            return {
                'target': url,
                'error': str(e),
                'vulnerabilities': []
            }
    
    def _assess_network_service(self, target):
        """
        Assess network service vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Check for common network service issues
            vulnerabilities.extend(self._check_open_ports(target))
            vulnerabilities.extend(self._check_service_versions(target))
            vulnerabilities.extend(self._check_default_credentials(target))
            
            return {
                'target': target,
                'assessment_type': 'network_service',
                'vulnerabilities': vulnerabilities,
                'total_vulnerabilities': len(vulnerabilities),
                'risk_level': self._calculate_risk_level(vulnerabilities)
            }
            
        except Exception as e:
            return {
                'target': target,
                'error': str(e),
                'vulnerabilities': []
            }
    
    def _assess_ssl_tls(self, target):
        """
        Assess SSL/TLS configuration
        """
        vulnerabilities = []
        
        try:
            if not target.startswith(('https://', 'ssl://')):
                target = 'https://' + target
            
            parsed_url = urlparse(target)
            hostname = parsed_url.hostname
            port = parsed_url.port or 443
            
            # Check SSL/TLS configuration
            vulnerabilities.extend(self._check_ssl_certificate(hostname, port))
            vulnerabilities.extend(self._check_ssl_protocols(hostname, port))
            vulnerabilities.extend(self._check_ssl_ciphers(hostname, port))
            
            return {
                'target': target,
                'assessment_type': 'ssl_tls',
                'vulnerabilities': vulnerabilities,
                'total_vulnerabilities': len(vulnerabilities),
                'risk_level': self._calculate_risk_level(vulnerabilities)
            }
            
        except Exception as e:
            return {
                'target': target,
                'error': str(e),
                'vulnerabilities': []
            }
    
    def _check_http_headers(self, url):
        """
        Check for missing security headers
        """
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'Strict-Transport-Security': 'HSTS header missing',
                'Content-Security-Policy': 'CSP header missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'name': f'Missing {header} Header',
                        'type': f'Missing {header} Header',  # Added for compatibility
                        'severity': 'medium',  # Lowercase for consistency
                        'description': description,
                        'impact': 'Reduced security against common web attacks',
                        'recommendation': f'Add {header} header to web server configuration'
                    })
            
            # Check for information disclosure
            server_header = headers.get('Server', '')
            if server_header:
                vulnerabilities.append({
                    'name': 'Server Information Disclosure',
                    'type': 'Server Information Disclosure',  # Added for compatibility
                    'severity': 'low',  # Lowercase for consistency
                    'description': f'Server header reveals: {server_header}',
                    'impact': 'Information useful for attackers',
                    'recommendation': 'Remove or obfuscate server version information'
                })
                
        except Exception as e:
            vulnerabilities.append({
                'name': 'HTTP Header Check Failed',
                'type': 'HTTP Header Check Failed',  # Added for compatibility
                'severity': 'low',  # Lowercase for consistency
                'description': f'Unable to check headers: {str(e)}',
                'impact': 'Assessment incomplete',
                'recommendation': 'Manual verification required'
            })
        
        return vulnerabilities
    
    def _check_directory_traversal(self, url):
        """
        Check for directory traversal vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Test common directory traversal payloads
            payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64'
            ]
            
            for payload in payloads:
                test_url = f"{url}/{payload}"
                try:
                    response = self.session.get(test_url, timeout=5, verify=False)
                    
                    # Check for common indicators of successful traversal
                    content = response.text.lower()
                    if any(indicator in content for indicator in ['root:', 'bin/', '# localhost']):
                        vulnerabilities.append({
                            'name': 'Directory Traversal Vulnerability',
                            'type': 'Directory Traversal Vulnerability',
                            'severity': 'high',
                            'description': f'Directory traversal possible with payload: {payload}',
                            'impact': 'Unauthorized file system access',
                            'recommendation': 'Implement proper input validation and file access controls'
                        })
                        break
                        
                except:
                    continue
                    
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_xss_reflection(self, url):
        """
        Check for reflected XSS vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Test for XSS reflection
            xss_payload = '<script>alert("XSS")</script>'
            test_params = ['q', 'search', 'query', 'input', 'data']
            
            for param in test_params:
                test_url = f"{url}?{param}={xss_payload}"
                try:
                    response = self.session.get(test_url, timeout=5, verify=False)
                    
                    if xss_payload in response.text:
                        vulnerabilities.append({
                            'name': 'Reflected XSS Vulnerability',
                            'severity': 'High',
                            'description': f'XSS reflection found in parameter: {param}',
                            'impact': 'Client-side code execution, session hijacking',
                            'recommendation': 'Implement proper input validation and output encoding'
                        })
                        
                except:
                    continue
                    
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_sql_injection(self, url):
        """
        Check for SQL injection vulnerabilities
        """
        vulnerabilities = []
        
        try:
            # Test for SQL injection
            sql_payloads = ["'", "' OR '1'='1", "'; DROP TABLE users; --"]
            test_params = ['id', 'user', 'page', 'category', 'item']
            
            for param in test_params:
                for payload in sql_payloads:
                    test_url = f"{url}?{param}={payload}"
                    try:
                        response = self.session.get(test_url, timeout=5, verify=False)
                        
                        # Check for SQL error indicators
                        error_indicators = [
                            'sql syntax', 'mysql_fetch', 'ora-', 'mssql_query',
                            'pg_exec', 'sqlite_', 'column_name'
                        ]
                        
                        content = response.text.lower()
                        if any(indicator in content for indicator in error_indicators):
                            vulnerabilities.append({
                                'name': 'SQL Injection Vulnerability',
                                'severity': 'Critical',
                                'description': f'SQL injection possible in parameter: {param}',
                                'impact': 'Database compromise, data theft',
                                'recommendation': 'Use parameterized queries and input validation'
                            })
                            break
                            
                    except:
                        continue
                        
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_information_disclosure(self, url):
        """
        Check for information disclosure issues
        """
        vulnerabilities = []
        
        try:
            # Check for common sensitive files
            sensitive_files = [
                'robots.txt', '.htaccess', 'web.config', 'phpinfo.php',
                'admin/', 'backup/', '.git/', '.svn/'
            ]
            
            for file_path in sensitive_files:
                test_url = f"{url}/{file_path}"
                try:
                    response = self.session.get(test_url, timeout=5, verify=False)
                    
                    if response.status_code == 200 and len(response.content) > 0:
                        vulnerabilities.append({
                            'name': 'Information Disclosure',
                            'severity': 'Medium',
                            'description': f'Sensitive file accessible: {file_path}',
                            'impact': 'Information useful for attackers',
                            'recommendation': f'Restrict access to {file_path}'
                        })
                        
                except:
                    continue
                    
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_open_ports(self, target):
        """
        Check for risky open ports
        """
        vulnerabilities = []
        
        try:
            risky_ports = {
                21: 'FTP - Unencrypted file transfer',
                23: 'Telnet - Unencrypted remote access',
                135: 'RPC - Remote procedure call',
                139: 'NetBIOS - Legacy Windows protocol',
                445: 'SMB - File sharing protocol',
                1433: 'MSSQL - Database server',
                3306: 'MySQL - Database server',
                5432: 'PostgreSQL - Database server'
            }
            
            for port, description in risky_ports.items():
                if self._is_port_open(target, port):
                    vulnerabilities.append({
                        'name': f'Risky Open Port {port}',
                        'severity': 'Medium',
                        'description': description,
                        'impact': 'Potential attack vector',
                        'recommendation': f'Close port {port} if not required, or restrict access'
                    })
                    
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_service_versions(self, target):
        """
        Check for outdated service versions (simplified)
        """
        vulnerabilities = []
        
        # This would typically involve banner grabbing and version detection
        # For now, we'll return a placeholder result
        try:
            # Simplified check - in practice, this would be much more comprehensive
            if self._is_port_open(target, 22):
                vulnerabilities.append({
                    'name': 'SSH Service Detected',
                    'severity': 'Info',
                    'description': 'SSH service is running',
                    'impact': 'Verify SSH configuration and version',
                    'recommendation': 'Ensure SSH is updated and properly configured'
                })
                
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_default_credentials(self, target):
        """
        Check for default credentials (simplified)
        """
        vulnerabilities = []
        
        # This would typically test common default credentials
        # For now, we'll return a general recommendation
        vulnerabilities.append({
            'name': 'Default Credential Check',
            'severity': 'Info',
            'description': 'Manual verification required for default credentials',
            'impact': 'Potential unauthorized access',
            'recommendation': 'Verify all services use strong, unique credentials'
        })
        
        return vulnerabilities
    
    def _check_ssl_certificate(self, hostname, port):
        """
        Check SSL certificate configuration
        """
        vulnerabilities = []
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    import datetime
                    not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (not_after - datetime.datetime.now()).days
                    
                    if days_until_expiry < 30:
                        vulnerabilities.append({
                            'name': 'SSL Certificate Expiring Soon',
                            'severity': 'High' if days_until_expiry < 7 else 'Medium',
                            'description': f'Certificate expires in {days_until_expiry} days',
                            'impact': 'Service disruption, security warnings',
                            'recommendation': 'Renew SSL certificate before expiration'
                        })
                    
        except Exception as e:
            vulnerabilities.append({
                'name': 'SSL Certificate Check Failed',
                'severity': 'Medium',
                'description': f'Unable to verify SSL certificate: {str(e)}',
                'impact': 'SSL configuration may be problematic',
                'recommendation': 'Manual SSL certificate verification required'
            })
        
        return vulnerabilities
    
    def _check_ssl_protocols(self, hostname, port):
        """
        Check for weak SSL/TLS protocols
        """
        vulnerabilities = []
        
        try:
            # Check for weak protocols (simplified)
            weak_protocols = ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']
            
            # This is a simplified check - actual implementation would test each protocol
            vulnerabilities.append({
                'name': 'SSL Protocol Configuration',
                'severity': 'Info',
                'description': 'Manual verification of SSL protocols required',
                'impact': 'Weak protocols may be vulnerable to attacks',
                'recommendation': 'Disable SSLv2, SSLv3, TLSv1.0, and TLSv1.1. Use TLSv1.2 or higher'
            })
            
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_ssl_ciphers(self, hostname, port):
        """
        Check for weak SSL ciphers
        """
        vulnerabilities = []
        
        try:
            # This would typically enumerate and test cipher suites
            vulnerabilities.append({
                'name': 'SSL Cipher Configuration',
                'severity': 'Info',
                'description': 'Manual verification of cipher suites required',
                'impact': 'Weak ciphers may be vulnerable to attacks',
                'recommendation': 'Use strong cipher suites and disable weak ones'
            })
            
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _is_port_open(self, target, port, timeout=3):
        """
        Check if a port is open
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((target, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def _calculate_risk_level(self, vulnerabilities):
        """
        Calculate overall risk level based on vulnerabilities
        """
        if not vulnerabilities:
            return 'Low'
        
        critical_count = sum(1 for v in vulnerabilities if v.get('severity') == 'Critical')
        high_count = sum(1 for v in vulnerabilities if v.get('severity') == 'High')
        
        if critical_count > 0:
            return 'Critical'
        elif high_count > 2:
            return 'High'
        elif high_count > 0:
            return 'Medium'
        else:
            return 'Low'
